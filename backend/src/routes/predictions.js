const express = require('express');
const { body, validationResult } = require('express-validator');
const { authenticateToken: protect } = require('../middleware/auth');
// eslint-disable-next-line no-unused-vars
const logger = require('../utils/logger');
// eslint-disable-next-line no-unused-vars
const predictionService = require('../services/predictionService');

const router = express.Router();

// @route   POST /api/predictions/predict
// @desc    ?êÊ∏¨?°Á??πÊ†º
// @access  Private
router.post(
  '/predict',
  protect,
  [
    body('cardId').isInt({ min: 1 }).withMessage('?°Á?IDÂøÖÈ??ØÊ≠£?¥Êï∏'),
    body('timeframe')
      .isIn(['1d', '7d', '30d', '90d', '180d', '365d'])
      .withMessage('?ÇÈ?Ê°ÜÊû∂ÂøÖÈ???d??d??0d??0d??80d??65d'),
    body('modelType')
      .optional()
      .isIn([
        'linear',
        'polynomial',
        'exponential',
        'arima',
        'lstm',
        'ensemble',
      ])
      .withMessage(
        'Ê®°Â?È°ûÂ?ÂøÖÈ??Ølinear?Åpolynomial?Åexponential?Åarima?Ålstm?ñensemble'
      ),
  ],
  async (req, res) => {
    try {
// eslint-disable-next-line no-unused-vars
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Ëº∏ÂÖ•È©óË?Â§±Ê?',
          code: 'VALIDATION_ERROR',
          errors: errors.array(),
        });
      }

      const { cardId, timeframe, modelType = 'ensemble' } = req.body;

      // ?∑Ë??êÊ∏¨
// eslint-disable-next-line no-unused-vars
      const prediction = await predictionService.predictCardPrice(
        cardId,
        timeframe,
        modelType
      );

      logger.info(
        `?πÊ†º?êÊ∏¨: ?®Êà∂ ${req.user.username} ?êÊ∏¨?°Á? ${cardId}, Ê®°Â? ${modelType}, ?ÇÈ?Ê°ÜÊû∂ ${timeframe}`
      );

      res.json({
        success: true,
        message: '?êÊ∏¨ÂÆåÊ?',
        data: { prediction },
      });
    } catch (error) {
      logger.error('?πÊ†º?êÊ∏¨?ØË™§:', error);
      res.status(500).json({
        success: false,
        message: error.message || '?êÊ∏¨Â§±Ê?',
        code: 'PREDICTION_FAILED',
      });
    }
  }
);

// @route   GET /api/predictions/history/:cardId
// @desc    ?≤Â??êÊ∏¨Ê≠∑Âè≤
// @access  Private
router.get(
  '/history/:cardId',
  protect,
  [
    body('limit')
      .optional()
      .isInt({ min: 1, max: 100 })
      .withMessage('?êÂà∂?∏È?ÂøÖÈ???-100‰πãÈ?'),
  ],
  async (req, res) => {
    try {
      const { cardId } = req.params;
      const { limit = 50 } = req.query;

      // ?≤Â??êÊ∏¨Ê≠∑Âè≤
// eslint-disable-next-line no-unused-vars
      const predictions = await predictionService.getPredictionHistory(
        parseInt(cardId),
        parseInt(limit)
      );

      logger.info(
        `?≤Â??êÊ∏¨Ê≠∑Âè≤: ?®Êà∂ ${req.user.username} ?•Á??°Á? ${cardId} ?ÑÈ?Ê∏¨Ê≠∑?≤`
      );

      res.json({
        success: true,
        message: '?êÊ∏¨Ê≠∑Âè≤?≤Â??êÂ?',
        data: {
          predictions,
          total: predictions.length,
          cardId: parseInt(cardId),
        },
      });
    } catch (error) {
      logger.error('?≤Â??êÊ∏¨Ê≠∑Âè≤?ØË™§:', error);
      res.status(500).json({
        success: false,
        message: error.message || '?≤Â??êÊ∏¨Ê≠∑Âè≤Â§±Ê?',
        code: 'HISTORY_FETCH_FAILED',
      });
    }
  }
);

// @route   POST /api/predictions/accuracy/:predictionId
// @desc    Ë®àÁ??êÊ∏¨Ê∫ñÁ¢∫??// @access  Private
router.post('/accuracy/:predictionId', protect, async (req, res) => {
  try {
    const { predictionId } = req.params;

    // Ë®àÁ??êÊ∏¨Ê∫ñÁ¢∫??    const accuracy = await predictionService.calculatePredictionAccuracy(
      parseInt(predictionId)
    );

    if (!accuracy) {
      return res.json({
        success: true,
        message: '?ÆÊ??•Ê??ÑÊ??âÂØ¶?õÊï∏?öÔ??°Ê?Ë®àÁ?Ê∫ñÁ¢∫??,
        data: { accuracy: null },
      });
    }

    logger.info(
      `Ë®àÁ??êÊ∏¨Ê∫ñÁ¢∫?? ?®Êà∂ ${req.user.username} Ë®àÁ??êÊ∏¨ ${predictionId} ?ÑÊ?Á¢∫ÊÄß`
    );

    res.json({
      success: true,
      message: 'Ê∫ñÁ¢∫?ßË?ÁÆóÂ???,
      data: { accuracy },
    });
  } catch (error) {
    logger.error('Ë®àÁ??êÊ∏¨Ê∫ñÁ¢∫?ßÈåØË™?', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Ë®àÁ?Ê∫ñÁ¢∫?ßÂ§±??,
      code: 'ACCURACY_CALCULATION_FAILED',
    });
  }
});

// @route   POST /api/predictions/batch
// @desc    ?πÈ??êÊ∏¨
// @access  Private
router.post(
  '/batch',
  protect,
  [
    body('cardIds')
      .isArray({ min: 1, max: 10 })
      .withMessage('?°Á?IDÂøÖÈ??ØÂ???-10?ãÂ?Á¥†Á??∏Á?'),
    body('timeframe')
      .isIn(['1d', '7d', '30d', '90d', '180d', '365d'])
      .withMessage('?ÇÈ?Ê°ÜÊû∂ÂøÖÈ???d??d??0d??0d??80d??65d'),
    body('modelType')
      .optional()
      .isIn([
        'linear',
        'polynomial',
        'exponential',
        'arima',
        'lstm',
        'ensemble',
      ])
      .withMessage(
        'Ê®°Â?È°ûÂ?ÂøÖÈ??Ølinear?Åpolynomial?Åexponential?Åarima?Ålstm?ñensemble'
      ),
  ],
  async (req, res) => {
    try {
// eslint-disable-next-line no-unused-vars
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Ëº∏ÂÖ•È©óË?Â§±Ê?',
          code: 'VALIDATION_ERROR',
          errors: errors.array(),
        });
      }

      const { cardIds, timeframe, modelType = 'ensemble' } = req.body;

      // ?πÈ??êÊ∏¨
// eslint-disable-next-line no-unused-vars
      const predictions = [];
// eslint-disable-next-line no-unused-vars
      const predictionErrors = [];

      for (const cardId of cardIds) {
        try {
// eslint-disable-next-line no-unused-vars
          const prediction = await predictionService.predictCardPrice(
            cardId,
            timeframe,
            modelType
          );
          predictions.push(prediction);
        } catch (error) {
          predictionErrors.push({
            cardId,
            error: error.message,
          });
          logger.warn(`?πÈ??êÊ∏¨Â§±Ê? - ?°Á? ${cardId}:`, error.message);
        }
      }

      logger.info(
        `?πÈ??êÊ∏¨: ?®Êà∂ ${req.user.username} ?πÈ??êÊ∏¨ ${cardIds.length} ÂºµÂç°?å`
      );

      res.json({
        success: true,
        message: '?πÈ??êÊ∏¨ÂÆåÊ?',
        data: {
          predictions,
          errors: predictionErrors,
          summary: {
            total: cardIds.length,
            successful: predictions.length,
            failed: predictionErrors.length,
          },
        },
      });
    } catch (error) {
      logger.error('?πÈ??êÊ∏¨?ØË™§:', error);
      res.status(500).json({
        success: false,
        message: error.message || '?πÈ??êÊ∏¨Â§±Ê?',
        code: 'BATCH_PREDICTION_FAILED',
      });
    }
  }
);

// @route   GET /api/predictions/models
// @desc    ?≤Â??ØÁî®Ê®°Â??óË°®
// @access  Private
router.get('/models', protect, async (req, res) => {
  try {
// eslint-disable-next-line no-unused-vars
    const models = [
      {
        id: 'linear',
        name: 'Á∑öÊÄßÂ?Ê≠?,
        description: '?∫ÊñºÁ∑öÊÄßË∂®?¢Á?Á∞°ÂñÆ?êÊ∏¨Ê®°Â?',
        minDataPoints: 2,
        accuracy: '‰∏≠Á?',
        speed: 'Âø?,
        complexity: '‰Ω?,
      },
      {
        id: 'polynomial',
        name: 'Â§öÈ?ÂºèÂ?Ê≠?,
        description: '?ΩÂ??ïÊ??ûÁ??ßË∂®?¢Á??êÊ∏¨Ê®°Â?',
        minDataPoints: 3,
        accuracy: '‰∏≠È?',
        speed: '‰∏≠Á?',
        complexity: '‰∏≠Á?',
      },
      {
        id: 'exponential',
        name: '?áÊï∏Âπ≥Ê?',
        description: '?∫Êñº?ÇÈ?Â∫èÂ??ÑÂπ≥ÊªëÈ?Ê∏¨Ê®°??,
        minDataPoints: 2,
        accuracy: '‰∏≠Á?',
        speed: 'Âø?,
        complexity: '‰Ω?,
      },
      {
        id: 'arima',
        name: 'ARIMAÊ®°Â?',
        description: '?™Â?Ê≠∏Á??ÜÁßª?ïÂπ≥?áÊ®°?ãÔ??©Â??ÇÈ?Â∫èÂ??êÊ∏¨',
        minDataPoints: 10,
        accuracy: 'È´?,
        speed: '‰∏≠Á?',
        complexity: 'È´?,
      },
      {
        id: 'lstm',
        name: 'LSTMÁ•ûÁ?Á∂≤Áµ°',
        description: '?∑Áü≠?üË??∂Á∂≤Áµ°Ô??ΩÂ?Â≠∏Á?Ë§áÈ??ÑÊ??ìÊ®°Âº?,
        minDataPoints: 20,
        accuracy: 'ÂæàÈ?',
        speed: '??,
        complexity: 'ÂæàÈ?',
      },
      {
        id: 'ensemble',
        name: '?ÜÊ?Ê®°Â?',
        description: 'ÁµêÂ?Â§öÂÄãÊ®°?ãÁ??êÊ∏¨ÁµêÊ?ÔºåÊ?‰æõÊ?Á©©Â??ÑÈ?Ê∏?,
        minDataPoints: 5,
        accuracy: '?ÄÈ´?,
        speed: '‰∏≠Á?',
        complexity: '‰∏≠Á?',
      },
    ];

    logger.info(`?≤Â?Ê®°Â??óË°®: ?®Êà∂ ${req.user.username}`);

    res.json({
      success: true,
      message: 'Ê®°Â??óË°®?≤Â??êÂ?',
      data: { models },
    });
  } catch (error) {
    logger.error('?≤Â?Ê®°Â??óË°®?ØË™§:', error);
    res.status(500).json({
      success: false,
      message: '?≤Â?Ê®°Â??óË°®Â§±Ê?',
      code: 'MODELS_FETCH_FAILED',
    });
  }
});

// @route   GET /api/predictions/statistics
// @desc    ?≤Â??êÊ∏¨Áµ±Ë?‰ø°ÊÅØ
// @access  Private
router.get('/statistics', protect, async (req, res) => {
  try {
    const { getPredictionModel } = require('../models/PredictionModel');
    const PredictionModel = getPredictionModel();

    if (!PredictionModel) {
      throw new Error('?êÊ∏¨Ê®°Â??ùÂ??ñÂ§±??);
    }

    // ?≤Â?Áµ±Ë?‰ø°ÊÅØ
    const totalPredictions = await PredictionModel.count({
      where: { isActive: true },
    });

// eslint-disable-next-line no-unused-vars
    const recentPredictions = await PredictionModel.count({
      where: {
        isActive: true,
        predictionDate: {
          [require('sequelize').Op.gte]: new Date(
            Date.now() - 7 * 24 * 60 * 60 * 1000
          ), // ?ÄËø?Â§?        },
      },
    });

// eslint-disable-next-line no-unused-vars
    const modelStats = await PredictionModel.findAll({
      attributes: [
        'modelType',
        [
          require('sequelize').fn('COUNT', require('sequelize').col('id')),
          'count',
        ],
        [
          require('sequelize').fn(
            'AVG',
            require('sequelize').col('confidence')
          ),
          'avgConfidence',
        ],
        [
          require('sequelize').fn('AVG', require('sequelize').col('accuracy')),
          'avgAccuracy',
        ],
      ],
      where: { isActive: true },
      group: ['modelType'],
    });

    const accuracyStats = await PredictionModel.findAll({
      attributes: [
        [
          require('sequelize').fn('AVG', require('sequelize').col('accuracy')),
          'overallAccuracy',
        ],
        [
          require('sequelize').fn(
            'COUNT',
            require('sequelize').col('accuracy')
          ),
          'accuracyCount',
        ],
      ],
      where: {
        isActive: true,
        accuracy: {
          [require('sequelize').Op.not]: null,
        },
      },
    });

    logger.info(`?≤Â??êÊ∏¨Áµ±Ë?: ?®Êà∂ ${req.user.username}`);

    res.json({
      success: true,
      message: 'Áµ±Ë?‰ø°ÊÅØ?≤Â??êÂ?',
      data: {
        totalPredictions,
        recentPredictions,
        modelStats,
        accuracyStats: accuracyStats[0] || {
          overallAccuracy: 0,
          accuracyCount: 0,
        },
      },
    });
  } catch (error) {
    logger.error('?≤Â??êÊ∏¨Áµ±Ë??ØË™§:', error);
    res.status(500).json({
      success: false,
      message: error.message || '?≤Â?Áµ±Ë?‰ø°ÊÅØÂ§±Ê?',
      code: 'STATISTICS_FETCH_FAILED',
    });
  }
});

// @route   DELETE /api/predictions/:predictionId
// @desc    ?™Èô§?êÊ∏¨Ë®òÈ?
// @access  Private
router.delete('/:predictionId', protect, async (req, res) => {
  try {
    const { predictionId } = req.params;
    const { getPredictionModel } = require('../models/PredictionModel');
    const PredictionModel = getPredictionModel();

    if (!PredictionModel) {
      throw new Error('?êÊ∏¨Ê®°Â??ùÂ??ñÂ§±??);
    }

// eslint-disable-next-line no-unused-vars
    const prediction = await PredictionModel.findByPk(predictionId);
    if (!prediction) {
      return res.status(404).json({
        success: false,
        message: '?êÊ∏¨Ë®òÈ?‰∏çÂ???,
        code: 'PREDICTION_NOT_FOUND',
      });
    }

    // ËªüÂà™??    await prediction.update({ isActive: false });

    logger.info(
      `?™Èô§?êÊ∏¨Ë®òÈ?: ?®Êà∂ ${req.user.username} ?™Èô§?êÊ∏¨ ${predictionId}`
    );

    res.json({
      success: true,
      message: '?êÊ∏¨Ë®òÈ??™Èô§?êÂ?',
    });
  } catch (error) {
    logger.error('?™Èô§?êÊ∏¨Ë®òÈ??ØË™§:', error);
    res.status(500).json({
      success: false,
      message: error.message || '?™Èô§?êÊ∏¨Ë®òÈ?Â§±Ê?',
      code: 'PREDICTION_DELETE_FAILED',
    });
  }
});

module.exports = router;
