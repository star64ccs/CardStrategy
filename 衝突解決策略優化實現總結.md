# 衝突解決策略優化實現總結

## 概述

本次優化實現了多種衝突解決策略，大大增強了背景同步系統的數據一致性處理能力。通過提供多種解決策略和智能衝突檢測，確保了離線數據同步的可靠性和靈活性。

## 新增功能

### 1. 多種衝突解決策略

#### 服務器優先策略 (server-wins)
- **適用場景**: 服務器數據權威性高的場景
- **特點**: 當檢測到衝突時，優先使用服務器數據
- **置信度**: 0.8
- **使用場景**: 用戶配置、系統設置等

#### 客戶端優先策略 (client-wins)
- **適用場景**: 客戶端數據優先的場景
- **特點**: 當檢測到衝突時，優先使用客戶端數據
- **置信度**: 0.8
- **使用場景**: 用戶個人數據、本地偏好設置等

#### 智能合併策略 (merge)
- **適用場景**: 需要合併雙方數據的場景
- **特點**: 深度合併客戶端和服務器數據
- **置信度**: 0.7
- **使用場景**: 文檔編輯、配置合併等

#### 基於時間戳策略 (timestamp-based)
- **適用場景**: 基於時間先後判斷的場景
- **特點**: 根據時間戳差異決定合併或選擇較新數據
- **置信度**: 0.6-0.9（根據時間差異）
- **使用場景**: 日誌數據、時間敏感數據等

#### 字段級別合併策略 (field-level)
- **適用場景**: 需要精細控制合併的場景
- **特點**: 支持字段級別的自定義合併邏輯
- **置信度**: 0.8
- **使用場景**: 複雜對象的選擇性合併

#### 基於版本號策略 (version-based)
- **適用場景**: 有版本控制的數據
- **特點**: 根據版本號比較決定使用哪方數據
- **置信度**: 0.9
- **使用場景**: 文檔版本控制、API 版本管理等

#### 用戶選擇策略 (user-choice)
- **適用場景**: 需要用戶干預的衝突
- **特點**: 提供用戶界面讓用戶選擇
- **置信度**: 0.5（待實現）
- **使用場景**: 重要數據衝突、需要人工判斷的場景

#### 自定義策略 (custom)
- **適用場景**: 特殊業務邏輯的衝突解決
- **特點**: 支持自定義衝突解決邏輯
- **置信度**: 0.8
- **使用場景**: 特定業務規則、複雜合併邏輯

### 2. 智能衝突檢測

#### 衝突檢測邏輯
```typescript
private detectConflict(task: SyncTask, serverData: any): ConflictInfo | null {
  if (!task.body || !serverData) {
    return null;
  }

  const clientData = task.body;
  const clientTimestamp = task.lastModified || task.createdAt;
  const serverTimestamp = Date.now();

  // 檢查是否有實際衝突
  if (JSON.stringify(clientData) === JSON.stringify(serverData)) {
    return null;
  }

  return {
    taskId: task.id,
    field: 'root',
    clientValue: clientData,
    serverValue: serverData,
    clientTimestamp,
    serverTimestamp,
    clientVersion: task.version,
    serverVersion: serverData.version,
    conflictType: 'update',
    severity: this.calculateConflictSeverity(clientData, serverData)
  };
}
```

#### 衝突嚴重程度計算
- **低嚴重程度**: 衝突字段比例 < 30%
- **中等嚴重程度**: 衝突字段比例 30%-70%
- **高嚴重程度**: 衝突字段比例 > 70%

### 3. 衝突解決配置

#### 配置選項
```typescript
interface ConflictResolutionConfig {
  defaultStrategy: ConflictResolutionStrategy;
  enableAutoResolution: boolean;
  enableUserChoice: boolean;
  timestampThreshold: number;
  versionCheckEnabled: boolean;
  fieldLevelMerge: boolean;
  customResolvers: Record<string, (client: any, server: any) => any>;
}
```

#### 默認配置
```typescript
{
  defaultStrategy: 'server-wins',
  enableAutoResolution: true,
  enableUserChoice: true,
  timestampThreshold: 1000, // 1秒
  versionCheckEnabled: false,
  fieldLevelMerge: true,
  customResolvers: {},
}
```

### 4. 自定義解析器系統

#### 添加自定義解析器
```typescript
// 添加字段級別解析器
addCustomResolver('user_profile', (client, server) => {
  return {
    ...client,
    ...server,
    lastUpdated: Math.max(client.lastUpdated, server.lastUpdated)
  };
});

// 添加任務級別解析器
addCustomResolver('api_user_update', (client, server) => {
  // 自定義合併邏輯
  return customMergeLogic(client, server);
});
```

#### 解析器類型
- **字段級別解析器**: 針對特定字段的合併邏輯
- **任務級別解析器**: 針對特定任務類型的合併邏輯
- **通用解析器**: 可重用的合併邏輯

### 5. 衝突解決結果

#### 結果結構
```typescript
interface ConflictResolution {
  resolved: boolean;
  finalValue: any;
  strategy: ConflictResolutionStrategy;
  confidence: number; // 0-1，解決策略的置信度
  metadata?: Record<string, any>;
}
```

#### 結果示例
```typescript
{
  resolved: true,
  finalValue: { name: "Merged", value: 150 },
  strategy: "merge",
  confidence: 0.7,
  metadata: {
    mergedFields: ["name", "value"],
    reason: "智能合併客戶端和服務器數據"
  }
}
```

## 技術實現

### 1. 核心衝突解決邏輯

#### 主要方法
- `resolveConflict()`: 主要衝突解決入口
- `detectConflict()`: 衝突檢測
- `calculateConflictSeverity()`: 衝突嚴重程度計算
- `deepMerge()`: 深度合併
- `fieldLevelMerge()`: 字段級別合併

#### 策略實現
- `resolveServerWins()`: 服務器優先
- `resolveClientWins()`: 客戶端優先
- `resolveMerge()`: 智能合併
- `resolveTimestampBased()`: 基於時間戳
- `resolveFieldLevel()`: 字段級別合併
- `resolveVersionBased()`: 基於版本號
- `resolveUserChoice()`: 用戶選擇
- `resolveCustom()`: 自定義策略

### 2. 增強的任務處理

#### 衝突處理流程
```typescript
// 檢查是否需要衝突解決
if (response.status === 409) { // Conflict
  const serverData = await response.json();
  const resolution = await this.resolveConflict(task, serverData);
  
  if (resolution.resolved) {
    // 使用解決後的數據重新提交
    const retryResponse = await this.executeTask({
      ...task,
      body: resolution.finalValue
    });
    
    if (retryResponse.ok) {
      this.completeTask(task);
      logger.info('[Background Sync] 衝突解決成功，任務完成:', task.id, resolution.strategy);
    }
  }
}
```

### 3. React Hook 增強

#### 新增方法
- `setConflictResolutionStrategy()`: 設置任務的衝突解決策略
- `addCustomResolver()`: 添加自定義解析器
- `removeCustomResolver()`: 移除自定義解析器
- `updateConflictResolutionConfig()`: 更新衝突解決配置
- `testConflictResolution()`: 測試衝突解決策略

#### 狀態擴展
```typescript
export interface BackgroundSyncState {
  // ... 原有狀態
  conflictResolutionConfig: ConflictResolutionConfig;
}
```

### 4. UI 組件

#### ConflictResolutionPanel 組件
- **配置概覽**: 顯示當前衝突解決配置
- **測試工具**: 提供衝突解決策略測試功能
- **自定義解析器管理**: 添加、移除自定義解析器
- **任務策略設置**: 為特定任務設置衝突解決策略

#### 功能特點
- 實時配置更新
- 交互式策略測試
- 自定義解析器管理
- 任務級別策略設置

## 使用指南

### 1. 基本使用

#### 設置默認策略
```typescript
import { useBackgroundSync } from '@/hooks/useBackgroundSync';

const { updateConflictResolutionConfig } = useBackgroundSync();

// 設置默認策略為智能合併
updateConflictResolutionConfig({
  defaultStrategy: 'merge'
});
```

#### 為特定任務設置策略
```typescript
const { addApiTask, setConflictResolutionStrategy } = useBackgroundSync();

// 添加任務
const taskId = addApiTask('/api/user/profile', 'PUT', userData, 'high');

// 設置衝突解決策略
setConflictResolutionStrategy(taskId, 'timestamp-based');
```

### 2. 自定義解析器

#### 添加字段級別解析器
```typescript
const { addCustomResolver } = useBackgroundSync();

// 為用戶配置添加自定義解析器
addCustomResolver('user_settings', (client, server) => {
  return {
    ...client,
    ...server,
    theme: client.theme, // 客戶端主題優先
    language: server.language, // 服務器語言優先
    lastSync: Date.now()
  };
});
```

#### 添加任務級別解析器
```typescript
// 為特定 API 端點添加解析器
addCustomResolver('api_user_update', (client, server) => {
  // 複雜的業務邏輯合併
  return mergeUserData(client, server);
});
```

### 3. 衝突解決測試

#### 測試不同策略
```typescript
const { testConflictResolution } = useBackgroundSync();

const clientData = { name: "Client", value: 100 };
const serverData = { name: "Server", value: 200 };

// 測試智能合併
const mergeResult = await testConflictResolution(clientData, serverData, 'merge');
console.log('合併結果:', mergeResult);

// 測試時間戳策略
const timestampResult = await testConflictResolution(clientData, serverData, 'timestamp-based');
console.log('時間戳結果:', timestampResult);
```

### 4. 高級配置

#### 更新配置
```typescript
const { updateConflictResolutionConfig } = useBackgroundSync();

// 更新多個配置項
updateConflictResolutionConfig({
  defaultStrategy: 'field-level',
  timestampThreshold: 5000, // 5秒
  enableUserChoice: false,
  fieldLevelMerge: true
});
```

## 性能優化

### 1. 衝突檢測優化
- 使用 JSON.stringify 快速比較
- 避免不必要的深度比較
- 智能的衝突嚴重程度計算

### 2. 策略選擇優化
- 策略緩存機制
- 快速策略匹配
- 避免重複計算

### 3. 自定義解析器優化
- 解析器函數緩存
- 按需加載解析器
- 錯誤處理和回退機制

## 錯誤處理

### 1. 衝突解決失敗
- 自動回退到默認策略
- 詳細的錯誤日誌
- 用戶友好的錯誤提示

### 2. 自定義解析器錯誤
- 解析器錯誤隔離
- 自動回退到服務器優先
- 錯誤統計和監控

### 3. 配置錯誤
- 配置驗證
- 默認值回退
- 配置錯誤提示

## 監控和分析

### 1. 衝突統計
- 衝突發生頻率
- 策略使用分布
- 解決成功率

### 2. 性能監控
- 衝突解決時間
- 策略執行效率
- 自定義解析器性能

### 3. 錯誤分析
- 衝突解決失敗原因
- 策略選擇問題
- 自定義解析器錯誤

## 未來計劃

### 短期計劃
- [ ] 實現用戶選擇界面
- [ ] 添加更多預設解析器
- [ ] 實現衝突預測功能

### 中期計劃
- [ ] 實現機器學習優化的策略選擇
- [ ] 添加衝突解決歷史記錄
- [ ] 實現跨設備衝突解決

### 長期計劃
- [ ] 實現分布式衝突解決
- [ ] 添加實時衝突檢測
- [ ] 實現智能策略推薦

## 總結

本次衝突解決策略優化實現了以下重要改進：

1. **多樣化的解決策略** 提供8種不同的衝突解決策略，滿足不同場景需求
2. **智能衝突檢測** 自動檢測衝突並計算嚴重程度
3. **靈活的配置系統** 支持全局和任務級別的策略配置
4. **強大的自定義能力** 支持字段級別和任務級別的自定義解析器
5. **完善的測試工具** 提供衝突解決策略的測試功能
6. **友好的用戶界面** 提供豐富的管理和測試界面
7. **可靠的錯誤處理** 完善的錯誤處理和回退機制

這些改進使得背景同步系統能夠更好地處理數據衝突，確保數據一致性和用戶體驗，為應用的離線功能提供了強有力的支持。
